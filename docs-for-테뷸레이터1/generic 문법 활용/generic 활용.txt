==============================
Generic이 왜 쓰이나
==============================

코드:
  useRef<Set<number>>(new Set())
  useRef<Map<number, Employee>>(new Map())


1. Generic이 뭔가
==============================
  타입을 "나중에 지정"하는 문법. < > 안에 타입을 넣는 것.

  Set<number>       → number만 들어가는 Set
  Set<string>       → string만 들어가는 Set
  Map<number, Employee> → key가 number, value가 Employee인 Map

  Generic이 없으면:
    const s = new Set()
    s.add(-1)       // OK
    s.add("hello")  // OK ← 아무거나 다 들어감, 실수 가능

  Generic이 있으면:
    const s = new Set<number>()
    s.add(-1)       // OK
    s.add("hello")  // TS 에러 ← 컴파일 시점에 잡아줌


2. Generic이 없으면 어떻게 되나
==============================
  JS에서는 원래 Generic이 없음. TS에서만 쓰는 문법.
  없으면 동작은 하는데 타입 체크를 못 해서 실수를 못 잡음.

  // Generic 없이
  const s = new Set()
  s.add("hello")   // 실수인데 에러 안 남

  // Generic 있으면
  const s = new Set<number>()
  s.add("hello")   // TS가 빨간줄로 잡아줌


3.  Map에 Generic 을 적용하여 다음과 같이 활용
  a.  useRef<Map<number, Employee>>(new Map())

  b.  Map<number, Employee>
      → key는 number (행 ID)
      → value는 Employee (행 데이터)

  c.  useRef< ... >
      → 이 Map을 useRef로 감싼다

  d.  아래와 같이 활용
    modifiedRows.current.set(2, { id: 2, name: '홍길동', age: 30, position: '개발자' })

  e. 함수 전체:
    const handleSave = async () => {
    // 1) 신규 행 데이터 수집 (임시 ID 제거)
    const created: Omit<Employee, "id">[] = [];

    // 추가된 행에 해당하는것들만 모아서 created 배열에 추가
    for (const id of addedRows.current) {
      const row = tabulatorRef.current
        ?.getRows()
        .find((r) => r.getData().id === id);
      if (!row) continue;
      const { id: _tempId, ...data } = row.getData();
      created.push(data);
    }

    // 2) 수정된 행 데이터 수집
    // 수정된 행의 벨류만 가져와서 다시 배열로
    const updated = Array.from(modifiedRows.current.values());

    // 3) 삭제된 행 ID 수집
    // 삭제된 행의 아이디들을 배열로
    const deletedIdList = Array.from(deletedIds.current);

    // 변경사항 없으면 리턴
    if (
      created.length === 0 &&
      updated.length === 0 &&
      deletedIdList.length === 0
    ) {
      addLog("변경사항 없음");
      return;
    }

    // 4) 한 번에 전송
    const res = await fetch(`${API_URL}/batch`, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({
        created,
        updated,
        deletedIds: deletedIdList,
      }),
    });
    const result = await res.json();

    // 5) 서버 응답 후 테이블 새로고침 (정식 ID 반영)
    const reloadRes = await fetch(API_URL);
    const freshData = await reloadRes.json();
    tabulatorRef.current?.setData(freshData);

    // 6) 추적 초기화
    addedRows.current.clear();
    modifiedRows.current.clear();
    deletedIds.current.clear();

    addLog(
      `저장 완료 → 추가:${result.created.length}건, 수정:${result.updatedCount}건, 삭제:${result.deletedCount}건`,
    );
  };
