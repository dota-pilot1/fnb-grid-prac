==============================
행 추가/수정/삭제 + 저장 흐름 (batch 방식 - 정석)
==============================


[1단계] 페이지 진입 → 데이터 로드
----------------------------------------------
  GET /api/employees → table.setData(data)
  → 서버 데이터가 테이블에 표시됨


[2단계] 사용자 조작 (서버 통신 없음, 프론트에서만)
----------------------------------------------
  행 추가:
    addRow({ id: -1, ... })     → addedRows Set에 등록
  셀 편집:
    더블클릭 → 값 수정           → modifiedRows Map에 등록
  행 삭제:
    X 버튼 → row.delete()       → deletedIds Set에 등록

  이 시점에서 서버는 아무것도 모름.


[3단계] 저장 버튼 클릭 → 변경분 수집
----------------------------------------------
  // 1) 신규 행: addedRows에서 임시 ID로 행 찾아서 데이터 수집 (ID 제거)
  created = [
    { name: '홍길동', age: 30, position: '개발자' },
    { name: '김영수', age: 25, position: '디자이너' },
  ]

  // 2) 수정된 행: modifiedRows Map에서 값만 꺼냄
  updated = [
    { id: 2, name: '김철수(수정)', age: 26, position: '디자이너' },
  ]

  // 3) 삭제된 행: deletedIds Set에서 ID만 꺼냄
  deletedIds = [3, 5]


[4단계] 한 번에 서버 전송 (네트워크 요청 1번)
----------------------------------------------
  POST /api/employees/batch
  {
    "created": [{ name: '홍길동', ... }, ...],
    "updated": [{ id: 2, name: '김철수(수정)', ... }],
    "deletedIds": [3, 5]
  }


[5단계] 서버 처리 (NestJS)
----------------------------------------------
  1) deletedIds 순회 → 해당 행 삭제
  2) updated 순회 → 해당 행 수정
  3) created 순회 → 정식 ID 채번 후 추가

  응답:
  {
    "created": [{ id: 6, name: '홍길동', ... }, ...],
    "updatedCount": 1,
    "deletedCount": 2,
    "total": 5
  }


[6단계] 테이블 새로고침
----------------------------------------------
  GET /api/employees → table.setData(freshData)
  → 서버의 최신 데이터로 테이블 갱신 (정식 ID 반영)
  → 추적 초기화 (addedRows, modifiedRows, deletedIds 전부 clear)


왜 batch 방식인가
----------------------------------------------
  기존 (반복문 POST/PUT/DELETE):
    추가 3건 + 수정 2건 + 삭제 1건 = 네트워크 요청 6번

  batch:
    추가 3건 + 수정 2건 + 삭제 1건 = 네트워크 요청 1번

  - 네트워크 효율적
  - 서버에서 트랜잭션 처리 가능 (하나라도 실패하면 전체 롤백)
  - 실무에서 그리드 저장의 정석 패턴
